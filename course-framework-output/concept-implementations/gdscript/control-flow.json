[
  {
    "concept_id": "if-statements",
    "language_id": "gdscript",
    "explanation": "If statements in GDScript let you execute code conditionally. Like Python, GDScript uses indentation (tabs or spaces, but tabs are recommended). The condition must be followed by a colon. Commonly used for checking game states, player input, and collision detection.",
    "code_example": "# Basic if statement\nvar health = 50\n\nif health < 30:\n    print(\"Warning: Low health!\")\n    # Play warning sound\n    $WarningSound.play()\n\n# Checking player input\nif Input.is_action_pressed(\"ui_right\"):\n    position.x += speed * delta\n\nif Input.is_action_just_pressed(\"jump\"):\n    velocity.y = JUMP_VELOCITY\n\n# Checking collisions\nif is_on_floor():\n    print(\"Player is on the ground\")\n    can_jump = true\n\n# Checking node states\nif $AnimatedSprite2D.animation == \"idle\":\n    print(\"Player is idle\")\n\n# Multiple conditions with 'and'\nvar has_key = true\nvar door_locked = true\n\nif has_key and door_locked:\n    print(\"Unlock the door\")\n    door_locked = false\n\n# Multiple conditions with 'or'\nif health <= 0 or fell_off_map:\n    game_over()\n\n# Checking object existence\nif player != null:\n    var distance = global_position.distance_to(player.global_position)\n    print(\"Distance to player: \", distance)",
    "syntax_notes": "Use colon : after condition. Indent with tabs (Godot convention). Use 'and', 'or', 'not' for logical operations. Common checks: Input.is_action_pressed(), is_on_floor(), node != null.",
    "common_mistakes": "[\"Forgetting the colon after condition\", \"Using && or || instead of 'and' and 'or'\", \"Inconsistent indentation (mix of tabs and spaces)\", \"Using = instead of == for comparison\"]"
  },
  {
    "concept_id": "if-else",
    "language_id": "gdscript",
    "explanation": "The else clause provides an alternative path when the if condition is false. Essential for handling binary choices in games like hit/miss, alive/dead, grounded/airborne.",
    "code_example": "# Basic if-else\nvar health = 80\n\nif health > 50:\n    $HealthBar.modulate = Color.GREEN\n    print(\"Healthy\")\nelse:\n    $HealthBar.modulate = Color.RED\n    print(\"Injured\")\n\n# Movement direction\nif Input.is_action_pressed(\"move_right\"):\n    velocity.x = SPEED\n    $Sprite2D.flip_h = false\nelse:\n    velocity.x = 0\n    # Return to idle animation\n\n# Player state\nif is_on_floor():\n    # Can jump and move normally\n    if Input.is_action_just_pressed(\"jump\"):\n        velocity.y = JUMP_VELOCITY\nelse:\n    # In the air - apply gravity\n    velocity.y += GRAVITY * delta\n\n# Collision detection\nif body.is_in_group(\"enemies\"):\n    # Take damage\n    take_damage(10)\n    print(\"Hit by enemy!\")\nelse:\n    # Might be a collectible or neutral object\n    print(\"Touched: \", body.name)\n\n# Door interaction\nif has_key:\n    open_door()\n    has_key = false\n    print(\"Door unlocked!\")\nelse:\n    print(\"You need a key\")\n    $LockedSound.play()\n\n# Function with if-else return\nfunc get_movement_speed() -> float:\n    if is_sprinting:\n        return SPRINT_SPEED\n    else:\n        return WALK_SPEED",
    "syntax_notes": "else must be at same indentation as if. else also requires a colon. Only one branch executes. Common pattern: check game state, respond accordingly.",
    "common_mistakes": "[\"Putting a condition after else (use elif)\", \"Mismatching indentation between if and else\", \"Forgetting the colon after else\"]"
  },
  {
    "concept_id": "multiple-conditions",
    "language_id": "gdscript",
    "explanation": "Use elif (else if) to check multiple conditions in sequence. GDScript evaluates them top-to-bottom and executes only the first true branch. Perfect for state machines, animation selection, and difficulty levels.",
    "code_example": "# Health status\nvar health = 75\n\nif health >= 80:\n    $HealthBar.modulate = Color.GREEN\n    health_status = \"Excellent\"\nelif health >= 50:\n    $HealthBar.modulate = Color.YELLOW\n    health_status = \"Good\"\nelif health >= 20:\n    $HealthBar.modulate = Color.ORANGE\n    health_status = \"Warning\"\nelse:\n    $HealthBar.modulate = Color.RED\n    health_status = \"Critical\"\n    # Play alarm sound\n    $AlarmSound.play()\n\n# Animation selection\nif velocity.y < 0:\n    $AnimatedSprite2D.play(\"jump\")\nelif velocity.y > 0:\n    $AnimatedSprite2D.play(\"fall\")\nelif abs(velocity.x) > 0:\n    $AnimatedSprite2D.play(\"run\")\nelse:\n    $AnimatedSprite2D.play(\"idle\")\n\n# Enemy AI behavior\nvar distance_to_player = global_position.distance_to(player.global_position)\n\nif distance_to_player < 50:\n    # Too close - attack!\n    attack_player()\nelif distance_to_player < 200:\n    # In range - chase player\n    move_toward_player()\nelif distance_to_player < 500:\n    # Player nearby - patrol\n    patrol_area()\nelse:\n    # Player far away - idle\n    idle_behavior()\n\n# Input handling\nif Input.is_action_just_pressed(\"attack\"):\n    perform_attack()\nelif Input.is_action_just_pressed(\"dodge\"):\n    perform_dodge()\nelif Input.is_action_just_pressed(\"block\"):\n    raise_shield()\nelif Input.is_action_just_pressed(\"use_item\"):\n    use_current_item()\n\n# State machine\nenum State { IDLE, WALKING, RUNNING, JUMPING, FALLING, ATTACKING }\nvar current_state = State.IDLE\n\nif current_state == State.IDLE:\n    handle_idle_state()\nelif current_state == State.WALKING:\n    handle_walking_state()\nelif current_state == State.RUNNING:\n    handle_running_state()\nelif current_state == State.JUMPING:\n    handle_jumping_state()\nelif current_state == State.FALLING:\n    handle_falling_state()\nelif current_state == State.ATTACKING:\n    handle_attacking_state()\n\n# Match statement (alternative to many elif)\nmatch current_state:\n    State.IDLE:\n        handle_idle_state()\n    State.WALKING:\n        handle_walking_state()\n    State.RUNNING:\n        handle_running_state()\n    State.JUMPING:\n        handle_jumping_state()\n    _:  # Default case\n        print(\"Unknown state\")",
    "syntax_notes": "elif is short for 'else if'. Can have unlimited elif blocks. Only first true condition executes. else is optional. Use 'match' statement as cleaner alternative for many conditions.",
    "common_mistakes": "[\"Writing 'else if' instead of 'elif'\", \"Wrong order (specific conditions should come before general ones)\", \"Not considering that only ONE branch executes\"]"
  },
  {
    "concept_id": "for-loops",
    "language_id": "gdscript",
    "explanation": "For loops iterate over sequences like ranges, arrays, and dictionaries. In Godot, commonly used for processing multiple nodes, updating inventories, or spawning enemies. Use range() for numeric iteration.",
    "code_example": "# Loop with range\nfor i in range(5):\n    print(\"Count: \", i)  # Prints 0, 1, 2, 3, 4\n\n# range(start, stop, step)\nfor i in range(1, 11):\n    print(\"Level \", i)  # Prints 1 through 10\n\nfor i in range(0, 10, 2):\n    print(i)  # Prints 0, 2, 4, 6, 8\n\n# Loop over an array\nvar inventory = [\"sword\", \"shield\", \"potion\"]\n\nfor item in inventory:\n    print(\"You have: \", item)\n\n# Spawning multiple enemies\nfor i in range(5):\n    var enemy = enemy_scene.instantiate()\n    enemy.position = Vector2(i * 100, 100)\n    add_child(enemy)\n\n# Processing all children\nfor child in get_children():\n    if child is Enemy:\n        child.take_damage(10)\n\n# Loop with index (using enumerate pattern)\nvar weapons = [\"sword\", \"bow\", \"staff\"]\n\nfor i in range(weapons.size()):\n    print(\"Slot %d: %s\" % [i + 1, weapons[i]])\n\n# Dictionary iteration\nvar player_stats = {\n    \"health\": 100,\n    \"mana\": 50,\n    \"stamina\": 75\n}\n\nfor stat_name in player_stats:\n    print(\"%s: %d\" % [stat_name, player_stats[stat_name]])\n\n# Or iterate over both keys and values\nfor stat_name in player_stats.keys():\n    var value = player_stats[stat_name]\n    print(\"%s: %d\" % [stat_name, value])\n\n# Getting all nodes of a type\nfor enemy in get_tree().get_nodes_in_group(\"enemies\"):\n    var distance = global_position.distance_to(enemy.global_position)\n    if distance < 200:\n        enemy.alert_to_player()\n\n# Nested loop - creating grid\nfor y in range(10):\n    for x in range(10):\n        var tile = tile_scene.instantiate()\n        tile.position = Vector2(x * 32, y * 32)\n        add_child(tile)\n\n# Building animation frames\nfor frame in range(8):\n    var sprite_frame = load(\"res://sprites/walk_%d.png\" % frame)\n    $AnimatedSprite2D.frames.add_frame(\"walk\", sprite_frame)",
    "syntax_notes": "Use 'in' keyword for iteration. range(n) goes 0 to n-1. Arrays use .size() not len(). Use get_children() for node children. Use get_tree().get_nodes_in_group() for grouped nodes.",
    "common_mistakes": "[\"Expecting range(5) to include 5\", \"Using len() instead of .size() for arrays\", \"Modifying array while iterating over it\", \"Forgetting the colon after for statement\"]"
  },
  {
    "concept_id": "while-loops",
    "language_id": "gdscript",
    "explanation": "While loops repeat as long as a condition is true. Useful for game loops, waiting for conditions, and processing until complete. Be careful to ensure the condition eventually becomes false to avoid infinite loops.",
    "code_example": "# Basic while loop\nvar count = 0\nwhile count < 5:\n    print(\"Count: \", count)\n    count += 1\n\n# Depleting resources\nvar health = 100\nvar damage = 15\n\nwhile health > 0:\n    health -= damage\n    print(\"Health remaining: \", health)\n    if health <= 0:\n        print(\"Game Over\")\n\n# Waiting for player input (be careful with this in _process!)\nvar waiting_for_input = true\n\nfunc _input(event):\n    if event is InputEventKey and event.pressed:\n        waiting_for_input = false\n\n# Spawning enemies until limit reached\nvar enemy_count = 0\nvar max_enemies = 10\n\nfunc spawn_wave():\n    while enemy_count < max_enemies:\n        spawn_enemy()\n        enemy_count += 1\n        await get_tree().create_timer(0.5).timeout  # Wait between spawns\n\n# Processing queue\nvar action_queue = [\"move\", \"attack\", \"dodge\", \"heal\"]\n\nwhile action_queue.size() > 0:\n    var action = action_queue.pop_front()\n    execute_action(action)\n    await get_tree().create_timer(1.0).timeout  # Wait 1 second\n\n# Finding path to player\nvar current_node = start_node\nvar steps = 0\nvar max_steps = 100  # Prevent infinite loop\n\nwhile current_node != target_node and steps < max_steps:\n    current_node = find_next_node(current_node)\n    steps += 1\n\nif current_node == target_node:\n    print(\"Path found in %d steps\" % steps)\nelse:\n    print(\"No path found\")\n\n# Using break to exit early\nvar attempts = 0\nwhile attempts < 10:\n    if try_action():\n        print(\"Action succeeded!\")\n        break  # Exit loop early\n    attempts += 1\n    print(\"Attempt %d failed, trying again...\" % attempts)\n\n# Common pattern: game loop (not in _process!)\nvar game_running = true\n\nfunc run_game_loop():\n    while game_running:\n        process_input()\n        update_game_state()\n        render_frame()\n        await get_tree().process_frame  # Wait for next frame\n\n# Draining mana over time\nvar mana = 100\nvar drain_rate = 5\n\nfunc channel_spell():\n    while mana > 0 and is_channeling:\n        mana -= drain_rate\n        await get_tree().create_timer(0.1).timeout\n    \n    if mana <= 0:\n        print(\"Out of mana!\")\n        is_channeling = false",
    "syntax_notes": "Condition checked before each iteration. If starts false, never runs. Use 'break' to exit early. Use 'await' for delays in while loops. Be very careful with infinite loops - always have an exit condition.",
    "common_mistakes": "[\"Creating infinite loops (forgetting to update condition)\", \"Using while loops in _process() without await (freezes game)\", \"Not having a maximum iteration limit for safety\"]"
  },
  {
    "concept_id": "loop-control",
    "language_id": "gdscript",
    "explanation": "Use 'break' to exit a loop immediately and 'continue' to skip to the next iteration. Essential for early exits, filtering, and complex loop logic in game systems.",
    "code_example": "# break - exit loop early\nvar inventory = [\"sword\", \"potion\", \"shield\", \"key\", \"armor\"]\n\nfor item in inventory:\n    if item == \"key\":\n        print(\"Found the key!\")\n        break  # Stop searching\n    print(\"Checking: \", item)\n\n# Finding target in array\nvar enemies = get_tree().get_nodes_in_group(\"enemies\")\nvar target = null\n\nfor enemy in enemies:\n    if enemy.health > 0 and enemy.global_position.distance_to(position) < 200:\n        target = enemy\n        break  # Found closest alive enemy\n\n# continue - skip to next iteration\nfor i in range(10):\n    if i % 2 == 0:\n        continue  # Skip even numbers\n    print(\"Odd number: \", i)\n\n# Processing only valid nodes\nfor child in get_children():\n    if not child.visible:\n        continue  # Skip hidden nodes\n    \n    if not child is Enemy:\n        continue  # Skip non-enemy nodes\n    \n    # Only processes visible enemies\n    child.update_ai()\n\n# Validating user input\nfunc get_valid_position() -> Vector2:\n    while true:\n        var pos = get_random_position()\n        \n        # Skip if position is occupied\n        if is_position_occupied(pos):\n            continue\n        \n        # Skip if too close to player\n        if pos.distance_to(player_position) < 100:\n            continue\n        \n        # Valid position found!\n        return pos\n\n# Combat loop with break\nfunc battle(player, enemy):\n    while true:\n        player.attack(enemy)\n        if enemy.health <= 0:\n            print(\"Enemy defeated!\")\n            break\n        \n        enemy.attack(player)\n        if player.health <= 0:\n            print(\"Player defeated!\")\n            break\n        \n        await get_tree().create_timer(1.0).timeout\n\n# Processing array with both break and continue\nvar damage_values = [0, 5, 10, 0, 15, 20, 0]\n\nfor damage in damage_values:\n    if damage == 0:\n        continue  # Skip zero damage\n    \n    if damage >= 20:\n        print(\"Critical hit!\")\n        break  # Stop after critical\n    \n    print(\"Damage: \", damage)\n\n# Searching for collectibles\nfor node in get_tree().get_nodes_in_group(\"collectibles\"):\n    # Skip already collected items\n    if node.collected:\n        continue\n    \n    # Check if player is close enough\n    var distance = global_position.distance_to(node.global_position)\n    if distance < collection_radius:\n        collect_item(node)\n        break  # Only collect one per frame\n\n# Nested loops with break (only breaks inner loop)\nfor y in range(10):\n    for x in range(10):\n        if is_obstacle(x, y):\n            break  # Only breaks inner loop\n        place_tile(x, y)",
    "syntax_notes": "'break' exits the innermost loop completely. 'continue' skips to next iteration. Both work in for and while loops. Break only exits one loop level in nested loops.",
    "common_mistakes": "[\"Expecting break to exit all nested loops (only exits innermost)\", \"Forgetting that continue skips remaining loop code\", \"Using break/continue outside of loops\"]"
  },
  {
    "concept_id": "nested-loops",
    "language_id": "gdscript",
    "explanation": "Loops inside loops. The inner loop completes all iterations for each iteration of the outer loop. Essential for 2D grids, tile maps, and comparing all combinations of objects.",
    "code_example": "# Creating a 2D grid\nfor y in range(5):\n    for x in range(5):\n        var tile = tile_scene.instantiate()\n        tile.position = Vector2(x * 32, y * 32)\n        add_child(tile)\n        print(\"Placed tile at (%d, %d)\" % [x, y])\n\n# Pattern generation\nfor row in range(5):\n    var line = \"\"\n    for col in range(5):\n        line += \"* \"\n    print(line)\n# Output: 5 rows of \"* * * * * \"\n\n# Creating a tilemap with different tiles\nvar map = [\n    [1, 1, 1, 1, 1],\n    [1, 0, 0, 0, 1],\n    [1, 0, 2, 0, 1],\n    [1, 0, 0, 0, 1],\n    [1, 1, 1, 1, 1]\n]\n\nfor y in range(map.size()):\n    for x in range(map[y].size()):\n        var tile_type = map[y][x]\n        if tile_type == 1:\n            create_wall_tile(x, y)\n        elif tile_type == 2:\n            create_treasure_tile(x, y)\n        else:\n            create_floor_tile(x, y)\n\n# Checking collision between all enemies and projectiles\nvar enemies = get_tree().get_nodes_in_group(\"enemies\")\nvar projectiles = get_tree().get_nodes_in_group(\"projectiles\")\n\nfor enemy in enemies:\n    for projectile in projectiles:\n        if enemy.global_position.distance_to(projectile.global_position) < 20:\n            enemy.take_damage(projectile.damage)\n            projectile.queue_free()\n\n# Finding all pairs\nvar players = [\"Alice\", \"Bob\", \"Charlie\"]\n\nfor i in range(players.size()):\n    for j in range(i + 1, players.size()):  # Avoid duplicates\n        print(\"%s vs %s\" % [players[i], players[j]])\n\n# Pathfinding neighbors\nfunc get_neighbors(x: int, y: int) -> Array:\n    var neighbors = []\n    var directions = [[-1,0], [1,0], [0,-1], [0,1]]  # left, right, up, down\n    \n    for dir in directions:\n        var new_x = x + dir[0]\n        var new_y = y + dir[1]\n        \n        if is_valid_position(new_x, new_y):\n            neighbors.append(Vector2(new_x, new_y))\n    \n    return neighbors\n\n# Spawning enemy formations\nfor row in range(3):  # 3 rows\n    for col in range(5):  # 5 enemies per row\n        var enemy = enemy_scene.instantiate()\n        enemy.position = Vector2(col * 100 + 50, row * 80 + 50)\n        enemy.enemy_type = row  # Different type per row\n        add_child(enemy)\n\n# Breaking from nested loops (using flag)\nvar found = false\nfor y in range(10):\n    if found:\n        break\n    for x in range(10):\n        if treasure_at(x, y):\n            print(\"Treasure at (%d, %d)\" % [x, y])\n            found = true\n            break\n\n# 3D grid (triple nested)\nfor z in range(5):\n    for y in range(5):\n        for x in range(5):\n            create_voxel(x, y, z)",
    "syntax_notes": "Each loop needs proper indentation. Inner loop completes fully for each outer iteration. Break only exits innermost loop. Be careful with performance - O(nÂ²) or worse complexity.",
    "common_mistakes": "[\"Using same variable name for both loops\", \"Forgetting that break only exits one loop level\", \"Not considering performance with large datasets\", \"Confusing loop order\"]"
  }
]
