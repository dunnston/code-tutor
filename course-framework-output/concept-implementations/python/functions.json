[
  {
    "concept_id": "function-basics",
    "language_id": "python",
    "explanation": "Functions are reusable blocks of code that perform specific tasks. They help organize code, reduce repetition, and make programs easier to understand and maintain. Define functions with the 'def' keyword.",
    "code_example": "# Basic function definition\ndef greet():\n    print(\"Hello, adventurer!\")\n    print(\"Welcome to the quest!\")\n\n# Calling the function\ngreet()  # Executes the code inside\ngreet()  # Can call it multiple times\n\n# Function with multiple statements\ndef show_stats():\n    print(\"=== Character Stats ===\")\n    print(\"Health: 100\")\n    print(\"Mana: 50\")\n    print(\"Level: 5\")\n    print(\"=======================\")\n\nshow_stats()\n\n# Functions can call other functions\ndef start_adventure():\n    greet()\n    show_stats()\n    print(\"Your quest begins!\")\n\nstart_adventure()",
    "syntax_notes": "Function names follow the same rules as variables (snake_case recommended). Use def keyword, followed by name, parentheses, and colon. Indent the function body. Call functions by using their name with parentheses.",
    "common_mistakes": "[\"Forgetting parentheses when calling a function\", \"Not indenting the function body\", \"Calling a function before it's defined\", \"Forgetting the colon after def\"]"
  },
  {
    "concept_id": "parameters-arguments",
    "language_id": "python",
    "explanation": "Parameters allow functions to accept input data. Parameters are variables listed in the function definition. Arguments are the actual values passed when calling the function.",
    "code_example": "# Function with one parameter\ndef greet(name):\n    print(f\"Hello, {name}!\")\n\ngreet(\"Hero\")  # \"Hero\" is the argument\ngreet(\"Wizard\")  # \"Wizard\" is the argument\n\n# Multiple parameters\ndef calculate_damage(attack, defense):\n    damage = attack - defense\n    print(f\"Damage dealt: {damage}\")\n\ncalculate_damage(50, 10)  # attack=50, defense=10\n\n# Using parameter values\ndef create_character(name, level, character_class):\n    print(f\"Creating character...\")\n    print(f\"Name: {name}\")\n    print(f\"Level: {level}\")\n    print(f\"Class: {character_class}\")\n\ncreate_character(\"Aragorn\", 10, \"Ranger\")\n\n# Parameters can be used in calculations\ndef calculate_total_health(base_health, level):\n    total = base_health + (level * 10)\n    print(f\"Total health: {total}\")\n\ncalculate_total_health(100, 5)  # 100 + (5 * 10) = 150",
    "syntax_notes": "Parameters are defined in the function signature. Separate multiple parameters with commas. Arguments must be provided in the same order as parameters (unless using keyword arguments).",
    "common_mistakes": "[\"Providing arguments in the wrong order\", \"Wrong number of arguments (too many or too few)\", \"Confusing parameter names with variable names outside the function\", \"Forgetting that parameters are local to the function\"]"
  },
  {
    "concept_id": "return-values",
    "language_id": "python",
    "explanation": "Functions can send data back to the caller using the return statement. This allows functions to compute values that can be used elsewhere in your program. Once return is executed, the function exits immediately.",
    "code_example": "# Function that returns a value\ndef calculate_damage(attack, defense):\n    damage = attack - defense\n    return damage  # Send the value back\n\n# Capture the returned value\ntotal_damage = calculate_damage(50, 10)\nprint(f\"Damage: {total_damage}\")  # 40\n\n# Use return value directly\nprint(calculate_damage(30, 5))  # 25\n\n# Function with multiple returns (only one executes)\ndef get_rank(score):\n    if score >= 90:\n        return \"Gold\"\n    elif score >= 70:\n        return \"Silver\"\n    else:\n        return \"Bronze\"\n\nrank = get_rank(85)\nprint(f\"Your rank: {rank}\")  # \"Silver\"\n\n# Returning multiple values (as a tuple)\ndef get_character_info():\n    name = \"Hero\"\n    level = 5\n    health = 100\n    return name, level, health\n\nchar_name, char_level, char_health = get_character_info()\nprint(f\"{char_name}, Level {char_level}, HP: {char_health}\")\n\n# Using return values in expressions\ndef double(number):\n    return number * 2\n\nresult = double(5) + double(3)  # 10 + 6 = 16\nprint(result)\n\n# Function without return (returns None)\ndef show_message():\n    print(\"Hello!\")\n    # No return statement\n\nvalue = show_message()  # value will be None\nprint(value)  # None",
    "syntax_notes": "Use return to send a value back. Functions without return automatically return None. Code after return in the same block won't execute. Can return any type: numbers, strings, lists, etc.",
    "common_mistakes": "[\"Forgetting to capture the return value\", \"Using print instead of return\", \"Putting code after return (it won't run)\", \"Returning nothing when a value is expected\"]"
  },
  {
    "concept_id": "scope",
    "language_id": "python",
    "explanation": "Variable scope determines where variables can be accessed. Local variables exist only inside their function. Global variables exist outside functions and can be read anywhere (but should be modified carefully).",
    "code_example": "# Global variable\ngame_title = \"Epic Quest\"  # Accessible everywhere\n\ndef show_title():\n    # Can read global variables\n    print(f\"Playing: {game_title}\")\n\nshow_title()  # Works!\n\n# Local variable\ndef calculate_damage():\n    damage = 50  # Local to this function\n    print(f\"Damage: {damage}\")\n\ncalculate_damage()\n# print(damage)  # ERROR: damage doesn't exist outside the function\n\n# Same name, different scopes\nhealth = 100  # Global\n\ndef use_potion():\n    health = 120  # Local variable (doesn't change global)\n    print(f\"Inside function: {health}\")\n\nuse_potion()  # Prints 120\nprint(f\"Outside function: {health}\")  # Still prints 100\n\n# Modifying global variables (use carefully!)\nscore = 0  # Global\n\ndef add_points():\n    global score  # Explicitly declare we're using the global variable\n    score += 10\n\nprint(f\"Before: {score}\")  # 0\nadd_points()\nprint(f\"After: {score}\")  # 10\n\n# Parameters create local variables\ndef greet(name):  # name is local to this function\n    message = f\"Hello, {name}!\"  # message is also local\n    print(message)\n\ngreet(\"Hero\")\n# print(name)  # ERROR: name doesn't exist outside\n# print(message)  # ERROR: message doesn't exist outside\n\n# Better practice: return instead of modifying globals\ndef calculate_new_score(current_score, points):\n    return current_score + points\n\nscore = calculate_new_score(score, 10)  # Cleaner than using global",
    "syntax_notes": "Local variables are created inside functions and disappear when the function ends. Global variables exist outside functions. Use 'global' keyword to modify global variables (but this is often a code smell). Parameters are local variables.",
    "common_mistakes": "[\"Assuming local variables can be accessed outside their function\", \"Forgetting the 'global' keyword when trying to modify globals\", \"Overusing global variables (makes code hard to understand)\", \"Shadowing global variables unintentionally\"]"
  },
  {
    "concept_id": "default-parameters",
    "language_id": "python",
    "explanation": "Default parameters let you specify default values for function parameters. If an argument isn't provided when calling the function, the default value is used. This makes functions more flexible.",
    "code_example": "# Function with default parameter\ndef greet(name=\"Adventurer\"):\n    print(f\"Hello, {name}!\")\n\ngreet(\"Hero\")  # Hello, Hero!\ngreet()  # Hello, Adventurer! (uses default)\n\n# Multiple default parameters\ndef create_character(name, level=1, health=100):\n    print(f\"Name: {name}\")\n    print(f\"Level: {level}\")\n    print(f\"Health: {health}\")\n\ncreate_character(\"Wizard\")  # Uses defaults for level and health\ncreate_character(\"Warrior\", 5)  # Custom level, default health\ncreate_character(\"Ranger\", 3, 80)  # Custom all values\n\n# Keyword arguments (can skip positional order)\ncreate_character(name=\"Mage\", health=120)  # Uses default level=1\ncreate_character(\"Thief\", health=90, level=4)  # Order doesn't matter\n\n# Mixing required and optional parameters\ndef attack(attacker, target, damage=10, critical=False):\n    multiplier = 2 if critical else 1\n    total_damage = damage * multiplier\n    print(f\"{attacker} attacks {target} for {total_damage} damage!\")\n\nattack(\"Hero\", \"Goblin\")  # Uses defaults: damage=10, critical=False\nattack(\"Hero\", \"Dragon\", 50)  # Custom damage, default critical\nattack(\"Hero\", \"Boss\", 30, True)  # Custom both\nattack(\"Hero\", \"Troll\", critical=True)  # Default damage, custom critical\n\n# Practical example: configurable function\ndef print_health_bar(current, maximum=100, width=20):\n    percentage = current / maximum\n    filled = int(width * percentage)\n    bar = \"█\" * filled + \"░\" * (width - filled)\n    print(f\"Health: [{bar}] {current}/{maximum}\")\n\nprint_health_bar(75)  # Uses defaults\nprint_health_bar(50, 200)  # Custom maximum\nprint_health_bar(30, width=10)  # Custom width, default maximum",
    "syntax_notes": "Default parameters must come after required parameters. Use keyword arguments to skip to specific parameters. Don't use mutable defaults (like lists or dicts) - use None instead and create the object inside the function.",
    "common_mistakes": "[\"Putting default parameters before required ones\", \"Using mutable defaults (lists, dicts)\", \"Not understanding that defaults are evaluated once when function is defined\", \"Overcomplicating with too many default parameters\"]"
  }
]
