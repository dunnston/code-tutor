[
  {
    "concept_id": "lists-arrays",
    "language_id": "python",
    "explanation": "Lists are ordered, mutable collections that can hold items of any type. They're one of Python's most versatile data structures. Lists maintain insertion order and allow duplicate values.",
    "code_example": "# Creating lists\ninventory = [\"sword\", \"shield\", \"potion\"]\nnumbers = [1, 2, 3, 4, 5]\nmixed = [\"text\", 42, True, 3.14]  # Can mix types\nempty = []\n\n# Accessing elements (0-indexed)\nfirst_item = inventory[0]  # \"sword\"\nlast_item = inventory[-1]  # \"potion\" (negative indexing from end)\n\n# Modifying lists\ninventory[0] = \"magic sword\"  # Change an item\ninventory.append(\"helmet\")  # Add to end\ninventory.insert(1, \"bow\")  # Insert at specific position\nremoved = inventory.pop()  # Remove and return last item\ninventory.remove(\"shield\")  # Remove specific item\n\n# List operations\nlen(inventory)  # Get number of items\n\"sword\" in inventory  # Check if item exists (True/False)\ninventory.count(\"potion\")  # Count occurrences\n\n# Slicing\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nfirst_three = numbers[0:3]  # [0, 1, 2]\nmiddle = numbers[3:7]  # [3, 4, 5, 6]\nlast_three = numbers[-3:]  # [7, 8, 9]\nevery_other = numbers[::2]  # [0, 2, 4, 6, 8]\nreversed_list = numbers[::-1]  # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n\n# List methods\nnumbers = [3, 1, 4, 1, 5]\nnumbers.sort()  # Sort in place: [1, 1, 3, 4, 5]\nnumbers.reverse()  # Reverse in place: [5, 4, 3, 1, 1]\ncopy = numbers.copy()  # Create a shallow copy\nnumbers.clear()  # Remove all items\n\n# List comprehensions (advanced)\nsquares = [x ** 2 for x in range(5)]  # [0, 1, 4, 9, 16]\neven_numbers = [x for x in range(10) if x % 2 == 0]  # [0, 2, 4, 6, 8]\n\n# Nested lists\nmap_grid = [\n    [\".\", \".\", \"T\"],\n    [\".\", \"X\", \".\"],\n    [\".\", \".\", \".\"]\n]\ntreasure = map_grid[0][2]  # Access nested element",
    "syntax_notes": "Lists are mutable (can be changed). Use square brackets []. Indexing starts at 0. Negative indices count from the end. Slicing syntax: [start:stop:step].",
    "common_mistakes": "[\"Index out of range errors\", \"Forgetting that lists are mutable\", \"Modifying a list while iterating over it\", \"Confusing append (adds one item) with extend (adds multiple items)\"]"
  },
  {
    "concept_id": "dictionaries-objects",
    "language_id": "python",
    "explanation": "Dictionaries store key-value pairs, allowing fast lookups by key. They're unordered (before Python 3.7) or insertion-ordered (Python 3.7+). Keys must be immutable (strings, numbers, tuples).",
    "code_example": "# Creating dictionaries\ncharacter = {\n    \"name\": \"Hero\",\n    \"level\": 5,\n    \"health\": 100,\n    \"class\": \"Warrior\"\n}\n\n# Accessing values\nname = character[\"name\"]  # \"Hero\"\nlevel = character.get(\"level\")  # 5 (safer, returns None if missing)\ndefault_mana = character.get(\"mana\", 0)  # 0 (provides default)\n\n# Modifying dictionaries\ncharacter[\"health\"] = 120  # Update existing key\ncharacter[\"mana\"] = 50  # Add new key\ndel character[\"class\"]  # Remove key\nremoved_value = character.pop(\"level\")  # Remove and return value\n\n# Dictionary methods\nkeys = character.keys()  # Get all keys\nvalues = character.values()  # Get all values\nitems = character.items()  # Get key-value pairs\n\n# Looping through dictionaries\nfor key in character:\n    print(f\"{key}: {character[key]}\")\n\nfor key, value in character.items():\n    print(f\"{key}: {value}\")\n\n# Checking existence\nif \"health\" in character:\n    print(\"Health exists!\")\n\n# Nested dictionaries\ngame_state = {\n    \"player\": {\n        \"name\": \"Hero\",\n        \"stats\": {\"health\": 100, \"mana\": 50}\n    },\n    \"inventory\": [\"sword\", \"potion\"],\n    \"quests_completed\": 5\n}\n\nplayer_health = game_state[\"player\"][\"stats\"][\"health\"]  # 100\n\n# Dictionary comprehension\nsquares = {x: x ** 2 for x in range(5)}  # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}\n\n# Practical example\ninventory_counts = {\"potion\": 3, \"sword\": 1, \"shield\": 1}\ninventory_counts[\"potion\"] = inventory_counts.get(\"potion\", 0) + 1  # Add one",
    "syntax_notes": "Use curly braces {}. Separate key:value with colon. Separate pairs with commas. Keys must be immutable. Use get() for safe access.",
    "common_mistakes": "[\"Using mutable types as keys (lists, dicts)\", \"KeyError when accessing missing keys (use get() instead)\", \"Forgetting quotes around string keys\", \"Modifying dictionary while iterating\"]"
  },
  {
    "concept_id": "tuples",
    "language_id": "python",
    "explanation": "Tuples are immutable ordered collections. Once created, they cannot be modified. They're faster than lists and can be used as dictionary keys. Useful for fixed data that shouldn't change.",
    "code_example": "# Creating tuples\nposition = (10, 20)  # x, y coordinates\nrgb_color = (255, 128, 0)  # Red, Green, Blue\nsingle_item = (42,)  # Note the comma! Otherwise it's just a number\nempty = ()\n\n# Accessing elements (like lists)\nx = position[0]  # 10\ny = position[1]  # 20\nlast = rgb_color[-1]  # 0\n\n# Unpacking tuples\nx, y = position  # x=10, y=20\nred, green, blue = rgb_color  # red=255, green=128, blue=0\n\n# Tuples are immutable\n# position[0] = 15  # ERROR: Cannot modify tuple\n\n# But you can create a new tuple\nnew_position = (15, 25)\n\n# Tuple methods (limited because immutable)\nvalues = (1, 2, 3, 2, 1)\ncount = values.count(2)  # 2 (how many times 2 appears)\nindex = values.index(3)  # 2 (position of first 3)\n\n# Tuples can contain mutable objects\nplayer = (\"Hero\", [100, 50])  # Name and [health, mana]\nplayer[1][0] = 80  # Can modify the list inside tuple\n# But can't reassign: player[1] = [80, 50]  # ERROR\n\n# Using tuples as dictionary keys\nlocations = {\n    (0, 0): \"spawn\",\n    (10, 5): \"treasure\",\n    (15, 20): \"boss\"\n}\n\nlocation_type = locations[(10, 5)]  # \"treasure\"\n\n# Returning multiple values (actually returns a tuple)\ndef get_stats():\n    return 100, 50, 25  # Returns tuple (100, 50, 25)\n\nhealth, mana, stamina = get_stats()  # Unpack the tuple\n\n# Named tuples (more advanced)\nfrom collections import namedtuple\n\nPlayer = namedtuple('Player', ['name', 'level', 'health'])\nhero = Player(name=\"Hero\", level=5, health=100)\nprint(hero.name)  # Access by name\nprint(hero[0])  # Or by index",
    "syntax_notes": "Use parentheses (). Tuples are immutable. Single-item tuples need a trailing comma. Can be unpacked. Faster than lists for fixed data.",
    "common_mistakes": "[\"Forgetting the comma in single-item tuples\", \"Trying to modify tuples\", \"Confusing () for empty tuple vs function call\", \"Not recognizing that function multiple returns are tuples\"]"
  },
  {
    "concept_id": "sets",
    "language_id": "python",
    "explanation": "Sets are unordered collections of unique items. They automatically remove duplicates and provide fast membership testing. Great for removing duplicates or mathematical set operations.",
    "code_example": "# Creating sets\nunique_items = {\"sword\", \"shield\", \"potion\"}\nnumbers = {1, 2, 3, 4, 5}\nempty_set = set()  # Note: {} creates an empty dict, not set!\n\n# Sets automatically remove duplicates\nitems = {\"sword\", \"potion\", \"sword\", \"shield\", \"potion\"}\nprint(items)  # {\"sword\", \"potion\", \"shield\"} - only unique items\n\n# Creating set from list (removes duplicates)\nnumbers_list = [1, 2, 2, 3, 3, 3, 4, 5]\nunique_numbers = set(numbers_list)  # {1, 2, 3, 4, 5}\n\n# Adding and removing\ninventory = {\"sword\", \"shield\"}\ninventory.add(\"potion\")  # Add single item\ninventory.remove(\"shield\")  # Remove (raises error if not found)\ninventory.discard(\"bow\")  # Remove (no error if not found)\nitem = inventory.pop()  # Remove and return arbitrary item\ninventory.clear()  # Remove all items\n\n# Membership testing (very fast)\nitems = {\"sword\", \"shield\", \"potion\", \"helmet\", \"boots\"}\nif \"sword\" in items:  # O(1) - constant time!\n    print(\"You have a sword!\")\n\n# Set operations\nwarrior_items = {\"sword\", \"shield\", \"helmet\"}\nmage_items = {\"staff\", \"robe\", \"potion\"}\nshared_items = {\"helmet\", \"potion\"}\n\n# Union (all items from both sets)\nall_items = warrior_items | mage_items\n# or: all_items = warrior_items.union(mage_items)\n\n# Intersection (items in both sets)\ncommon = warrior_items & shared_items\n# or: common = warrior_items.intersection(shared_items)\n\n# Difference (items in first but not second)\nwarrior_only = warrior_items - mage_items\n# or: warrior_only = warrior_items.difference(mage_items)\n\n# Symmetric difference (items in either set but not both)\nexclusive = warrior_items ^ mage_items\n# or: exclusive = warrior_items.symmetric_difference(mage_items)\n\n# Subset/Superset checking\nbasic_items = {\"sword\", \"shield\"}\nif basic_items <= warrior_items:  # subset\n    print(\"All basic items are warrior items\")\n\n# Practical example: removing duplicate values\nvisited_locations = [\"town\", \"forest\", \"town\", \"cave\", \"forest\", \"town\"]\nunique_locations = set(visited_locations)  # {\"town\", \"forest\", \"cave\"}\nunique_list = list(unique_locations)  # Convert back to list",
    "syntax_notes": "Use curly braces {} or set(). Sets are unordered. Items must be immutable (hashable). No duplicates allowed. Fast for membership testing.",
    "common_mistakes": "[\"Using {} to create empty set (creates dict instead)\", \"Trying to add mutable items (lists, dicts)\", \"Expecting sets to maintain order\", \"Accessing by index (sets aren't ordered)\"]"
  }
]
