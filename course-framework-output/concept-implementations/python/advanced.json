[
  {
    "concept_id": "error-handling",
    "language_id": "python",
    "explanation": "Error handling using try/except blocks allows programs to gracefully handle errors instead of crashing. Catch specific exceptions, provide fallback behavior, and use finally for cleanup code.",
    "code_example": "# Basic try/except\ntry:\n    number = int(input(\"Enter a number: \"))\n    result = 100 / number\n    print(f\"Result: {result}\")\nexcept ValueError:\n    print(\"That's not a valid number!\")\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero!\")\n\n# Catching multiple exceptions\ntry:\n    value = int(\"not a number\")\nexcept (ValueError, TypeError) as e:\n    print(f\"Error occurred: {e}\")\n\n# Generic exception (catch-all)\ntry:\n    # Some risky operation\n    result = risky_function()\nexcept Exception as e:\n    print(f\"Unexpected error: {e}\")\n\n# try/except/else/finally\ntry:\n    file = open('data.txt', 'r')\n    content = file.read()\nexcept FileNotFoundError:\n    print(\"File not found!\")\n    content = \"\"  # Default value\nelse:\n    print(\"File read successfully!\")  # Only runs if no exception\nfinally:\n    print(\"Cleanup code\")  # Always runs\n    # file.close()  # If file was opened\n\n# Raising exceptions\ndef set_health(health):\n    if health < 0:\n        raise ValueError(\"Health cannot be negative!\")\n    if health > 100:\n        raise ValueError(\"Health cannot exceed 100!\")\n    return health\n\ntry:\n    player_health = set_health(150)\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n\n# Custom exceptions\nclass InsufficientManaError(Exception):\n    pass\n\nclass Character:\n    def __init__(self, mana):\n        self.mana = mana\n    \n    def cast_spell(self, cost):\n        if self.mana < cost:\n            raise InsufficientManaError(f\"Need {cost} mana, have {self.mana}\")\n        self.mana -= cost\n        return \"Spell cast!\"\n\nmage = Character(30)\ntry:\n    mage.cast_spell(50)\nexcept InsufficientManaError as e:\n    print(f\"Cannot cast spell: {e}\")\n\n# Re-raising exceptions\ndef process_data(data):\n    try:\n        return int(data)\n    except ValueError:\n        print(\"Logging error...\")\n        raise  # Re-raise the same exception\n\ntry:\n    process_data(\"invalid\")\nexcept ValueError:\n    print(\"Handled in outer try/except\")\n\n# Practical example: game save/load\ndef load_game(filename):\n    try:\n        with open(filename, 'r') as file:\n            import json\n            data = json.load(file)\n            return data\n    except FileNotFoundError:\n        print(\"No save file found. Starting new game.\")\n        return {\"level\": 1, \"health\": 100}  # Default data\n    except json.JSONDecodeError:\n        print(\"Save file is corrupted. Starting new game.\")\n        return {\"level\": 1, \"health\": 100}\n    except PermissionError:\n        print(\"Cannot access save file!\")\n        return None\n\ngame_data = load_game('save.json')\n\n# Assertions (for debugging)\ndef calculate_damage(attack, defense):\n    assert attack >= 0, \"Attack cannot be negative\"\n    assert defense >= 0, \"Defense cannot be negative\"\n    return max(0, attack - defense)\n\n# Only use assertions for debugging, not for user input validation!\n\n# Context managers with exceptions\nclass GameSession:\n    def __enter__(self):\n        print(\"Starting game session\")\n        return self\n    \n    def __exit__(self, exc_type, exc_value, traceback):\n        print(\"Ending game session\")\n        if exc_type is not None:\n            print(f\"Error occurred: {exc_value}\")\n        return False  # Don't suppress exception\n\nwith GameSession():\n    print(\"Playing game...\")\n    # Cleanup happens automatically even if error occurs",
    "syntax_notes": "Use try/except to catch errors. except clause specifies error type. Use 'as e' to access error message. finally always executes. else runs only if no exception. raise to throw exceptions.",
    "common_mistakes": "[\"Catching Exception too broadly\", \"Not providing helpful error messages\", \"Using exceptions for control flow\", \"Swallowing exceptions silently\", \"Using bare except: (catches everything, even KeyboardInterrupt)\"]"
  },
  {
    "concept_id": "async-basics",
    "language_id": "python",
    "explanation": "Asynchronous programming allows code to run concurrently without blocking. Use async/await for async functions, asyncio for managing async operations. Useful for I/O-bound tasks like network requests.",
    "code_example": "import asyncio\n\n# Basic async function\nasync def greet(name):\n    print(f\"Hello, {name}!\")\n    await asyncio.sleep(1)  # Non-blocking sleep\n    print(f\"Goodbye, {name}!\")\n\n# Running async function\nasyncio.run(greet(\"Hero\"))\n\n# Multiple concurrent tasks\nasync def fetch_player_data(player_id):\n    print(f\"Fetching data for player {player_id}...\")\n    await asyncio.sleep(2)  # Simulate network delay\n    return {\"id\": player_id, \"name\": f\"Player{player_id}\", \"level\": 5}\n\nasync def main():\n    # Run tasks concurrently\n    task1 = fetch_player_data(1)\n    task2 = fetch_player_data(2)\n    task3 = fetch_player_data(3)\n    \n    results = await asyncio.gather(task1, task2, task3)\n    for player in results:\n        print(f\"{player['name']} - Level {player['level']}\")\n\nasyncio.run(main())\n\n# Async with timeout\nasync def slow_operation():\n    await asyncio.sleep(10)\n    return \"Done\"\n\nasync def main():\n    try:\n        result = await asyncio.wait_for(slow_operation(), timeout=3)\n    except asyncio.TimeoutError:\n        print(\"Operation timed out!\")\n\nasyncio.run(main())\n\n# Game example: concurrent enemy updates\nasync def update_enemy(enemy_id):\n    while True:\n        print(f\"Enemy {enemy_id} attacking!\")\n        await asyncio.sleep(2)  # Attack every 2 seconds\n\nasync def update_player():\n    while True:\n        print(\"Player moving...\")\n        await asyncio.sleep(1)  # Update every second\n\nasync def game_loop():\n    # Run enemy and player updates concurrently\n    tasks = [\n        update_enemy(1),\n        update_enemy(2),\n        update_player()\n    ]\n    await asyncio.gather(*tasks)\n\n# asyncio.run(game_loop())  # This would run forever\n\n# Async context manager\nclass DatabaseConnection:\n    async def __aenter__(self):\n        print(\"Connecting to database...\")\n        await asyncio.sleep(1)\n        return self\n    \n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        print(\"Closing database connection...\")\n        await asyncio.sleep(0.5)\n\nasync def main():\n    async with DatabaseConnection() as db:\n        print(\"Using database...\")\n\nasyncio.run(main())\n\n# Callbacks (older style, pre-async/await)\nimport threading\nimport time\n\ndef fetch_data(callback):\n    def worker():\n        time.sleep(2)  # Simulate delay\n        data = {\"name\": \"Hero\", \"level\": 5}\n        callback(data)\n    \n    thread = threading.Thread(target=worker)\n    thread.start()\n\ndef handle_data(data):\n    print(f\"Received: {data}\")\n\nfetch_data(handle_data)\nprint(\"Fetching data in background...\")\ntime.sleep(3)  # Wait for callback\n\n# Practical example: async API calls\nasync def fetch_user_stats(user_id):\n    await asyncio.sleep(1)  # Simulate API call\n    return {\"user_id\": user_id, \"wins\": 10, \"losses\": 5}\n\nasync def fetch_user_inventory(user_id):\n    await asyncio.sleep(1)  # Simulate API call\n    return {\"user_id\": user_id, \"items\": [\"sword\", \"shield\"]}\n\nasync def get_complete_user_data(user_id):\n    # Fetch both concurrently (2x faster than sequential)\n    stats, inventory = await asyncio.gather(\n        fetch_user_stats(user_id),\n        fetch_user_inventory(user_id)\n    )\n    return {\"stats\": stats, \"inventory\": inventory}\n\nasync def main():\n    user_data = await get_complete_user_data(123)\n    print(user_data)\n\nasyncio.run(main())",
    "syntax_notes": "Use async def to define async functions. Use await to call async functions. asyncio.run() runs the main async function. asyncio.gather() runs multiple tasks concurrently. Use asyncio.sleep() not time.sleep() in async code.",
    "common_mistakes": "[\"Forgetting 'await' when calling async functions\", \"Using time.sleep() instead of asyncio.sleep()\", \"Not understanding that async != parallelism (it's concurrency)\", \"Mixing sync and async code incorrectly\"]"
  },
  {
    "concept_id": "regular-expressions",
    "language_id": "python",
    "explanation": "Regular expressions (regex) are patterns for matching and manipulating text. Python's re module provides regex functionality. Use raw strings (r'...') for regex patterns.",
    "code_example": "import re\n\n# Basic pattern matching\ntext = \"The hero has 100 health and 50 mana\"\npattern = r'\\d+'  # Match one or more digits\n\nmatches = re.findall(pattern, text)\nprint(matches)  # ['100', '50']\n\n# Searching for a pattern\nresult = re.search(r'health', text)\nif result:\n    print(f\"Found 'health' at position {result.start()}\")\n\n# Match at the start of string\ncommand = \"attack goblin\"\nif re.match(r'attack', command):\n    print(\"Attack command detected\")\n\n# Replacing text\ntext = \"The hero has 100 health\"\nnew_text = re.sub(r'\\d+', '150', text)\nprint(new_text)  # \"The hero has 150 health\"\n\n# Common patterns\n# \\d = digit, \\w = word character, \\s = whitespace\n# . = any character, * = 0 or more, + = 1 or more, ? = 0 or 1\n# [] = character set, ^ = start, $ = end\n\n# Validating email format\nemail = \"player@example.com\"\npattern = r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$'\nif re.match(pattern, email):\n    print(\"Valid email\")\n\n# Extracting username from email\nemail = \"hero123@example.com\"\nmatch = re.search(r'^([\\w]+)@', email)\nif match:\n    username = match.group(1)\n    print(f\"Username: {username}\")  # \"hero123\"\n\n# Capturing groups\ntext = \"Player: Hero, Level: 5, Score: 1000\"\npattern = r'Player: (\\w+), Level: (\\d+), Score: (\\d+)'\nmatch = re.search(pattern, text)\n\nif match:\n    name = match.group(1)  # \"Hero\"\n    level = match.group(2)  # \"5\"\n    score = match.group(3)  # \"1000\"\n    print(f\"{name} is level {level} with {score} points\")\n\n# Named groups (more readable)\npattern = r'Player: (?P<name>\\w+), Level: (?P<level>\\d+)'\nmatch = re.search(pattern, text)\n\nif match:\n    print(match.group('name'))  # \"Hero\"\n    print(match.group('level'))  # \"5\"\n\n# Splitting text\ntext = \"sword,shield,potion,helmet\"\nitems = re.split(r',', text)\nprint(items)  # ['sword', 'shield', 'potion', 'helmet']\n\n# Split on multiple delimiters\ntext = \"apple,banana;cherry:date\"\nitems = re.split(r'[,;:]', text)\nprint(items)  # ['apple', 'banana', 'cherry', 'date']\n\n# Finding all matches with groups\ntext = \"Health: 100, Mana: 50, Stamina: 75\"\npattern = r'(\\w+): (\\d+)'\nmatches = re.findall(pattern, text)\n\nfor stat, value in matches:\n    print(f\"{stat} = {value}\")\n# Health = 100\n# Mana = 50\n# Stamina = 75\n\n# Validating game commands\ncommands = [\"attack goblin\", \"move north\", \"use potion\", \"invalid123\"]\npattern = r'^(attack|move|use) (\\w+)$'\n\nfor command in commands:\n    if re.match(pattern, command):\n        print(f\"Valid: {command}\")\n    else:\n        print(f\"Invalid: {command}\")\n\n# Extracting numbers from text\ntext = \"Deal 25-50 damage with critical hits!\"\nnumbers = re.findall(r'\\d+', text)\nprint(numbers)  # ['25', '50']\n\n# More complex: validating password\npassword = \"Hero123!\"\n# At least 8 chars, 1 uppercase, 1 lowercase, 1 digit, 1 special\npattern = r'^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$'\n\nif re.match(pattern, password):\n    print(\"Strong password\")\n\n# Practical: parsing game logs\nlog_line = \"[2024-01-15 10:30:45] Player 'Hero' dealt 50 damage to 'Goblin'\"\npattern = r'\\[(.*?)\\] Player \\'(.*?)\\' dealt (\\d+) damage to \\'(.*?)\\''\nmatch = re.search(pattern, log_line)\n\nif match:\n    timestamp, player, damage, enemy = match.groups()\n    print(f\"At {timestamp}: {player} hit {enemy} for {damage} damage\")",
    "syntax_notes": "Use raw strings r'...' for regex patterns. re.search() finds first match. re.findall() finds all matches. re.sub() replaces. Use groups () to extract parts. \\d = digit, \\w = word char, \\s = space.",
    "common_mistakes": "[\"Not using raw strings r'...' (escaping gets messy)\", \"Making patterns too complex (hard to read/maintain)\", \"Not escaping special characters\", \"Expecting regex to solve everything (sometimes string methods are better)\"]"
  },
  {
    "concept_id": "testing-basics",
    "language_id": "python",
    "explanation": "Testing ensures code works correctly. Python's unittest module provides a framework for writing tests. Tests verify that functions return expected results and handle edge cases properly.",
    "code_example": "import unittest\n\n# Function to test\ndef calculate_damage(attack, defense):\n    \"\"\"Calculate damage after defense reduction.\"\"\"\n    damage = attack - defense\n    return max(0, damage)  # Damage can't be negative\n\n# Test class\nclass TestCombat(unittest.TestCase):\n    \n    def test_normal_damage(self):\n        \"\"\"Test basic damage calculation.\"\"\"\n        result = calculate_damage(50, 10)\n        self.assertEqual(result, 40)\n    \n    def test_no_damage(self):\n        \"\"\"Test when defense is higher than attack.\"\"\"\n        result = calculate_damage(10, 50)\n        self.assertEqual(result, 0)  # Should be 0, not negative\n    \n    def test_equal_values(self):\n        \"\"\"Test when attack equals defense.\"\"\"\n        result = calculate_damage(25, 25)\n        self.assertEqual(result, 0)\n    \n    def test_zero_defense(self):\n        \"\"\"Test with zero defense.\"\"\"\n        result = calculate_damage(30, 0)\n        self.assertEqual(result, 30)\n\n# Run tests\nif __name__ == '__main__':\n    unittest.main()\n\n# More assertion methods\nclass TestCharacter(unittest.TestCase):\n    \n    def setUp(self):\n        \"\"\"Run before each test.\"\"\"\n        self.character = Character(\"Hero\", 100)\n    \n    def test_health_positive(self):\n        self.assertGreater(self.character.health, 0)\n    \n    def test_name_not_empty(self):\n        self.assertIsNotNone(self.character.name)\n        self.assertTrue(len(self.character.name) > 0)\n    \n    def test_take_damage(self):\n        self.character.take_damage(30)\n        self.assertEqual(self.character.health, 70)\n    \n    def test_death(self):\n        self.character.take_damage(150)\n        self.assertFalse(self.character.is_alive())\n    \n    def test_invalid_health(self):\n        \"\"\"Test that invalid health raises error.\"\"\"\n        with self.assertRaises(ValueError):\n            Character(\"Test\", -10)\n\n# Common assertions:\n# assertEqual(a, b) - a == b\n# assertNotEqual(a, b) - a != b\n# assertTrue(x) - x is True\n# assertFalse(x) - x is False\n# assertGreater(a, b) - a > b\n# assertLess(a, b) - a < b\n# assertIn(a, b) - a in b\n# assertIsNone(x) - x is None\n# assertRaises(Exception) - code raises exception\n\n# Testing with fixtures (setup/teardown)\nclass TestDatabase(unittest.TestCase):\n    \n    def setUp(self):\n        \"\"\"Run before each test method.\"\"\"\n        print(\"Setting up test database\")\n        self.db = TestDatabase()\n    \n    def tearDown(self):\n        \"\"\"Run after each test method.\"\"\"\n        print(\"Cleaning up test database\")\n        self.db.close()\n    \n    @classmethod\n    def setUpClass(cls):\n        \"\"\"Run once before all tests in class.\"\"\"\n        print(\"Setting up test class\")\n    \n    @classmethod\n    def tearDownClass(cls):\n        \"\"\"Run once after all tests in class.\"\"\"\n        print(\"Tearing down test class\")\n\n# Simple testing without unittest (assertions)\ndef test_calculate_damage():\n    assert calculate_damage(50, 10) == 40, \"Basic damage failed\"\n    assert calculate_damage(10, 50) == 0, \"Negative damage check failed\"\n    assert calculate_damage(25, 25) == 0, \"Equal values failed\"\n    print(\"All tests passed!\")\n\ntest_calculate_damage()\n\n# Practical example: testing game logic\nclass Inventory:\n    def __init__(self):\n        self.items = []\n    \n    def add_item(self, item):\n        self.items.append(item)\n    \n    def remove_item(self, item):\n        if item in self.items:\n            self.items.remove(item)\n            return True\n        return False\n    \n    def has_item(self, item):\n        return item in self.items\n\nclass TestInventory(unittest.TestCase):\n    \n    def setUp(self):\n        self.inventory = Inventory()\n    \n    def test_add_item(self):\n        self.inventory.add_item(\"sword\")\n        self.assertIn(\"sword\", self.inventory.items)\n    \n    def test_remove_existing_item(self):\n        self.inventory.add_item(\"potion\")\n        result = self.inventory.remove_item(\"potion\")\n        self.assertTrue(result)\n        self.assertNotIn(\"potion\", self.inventory.items)\n    \n    def test_remove_nonexistent_item(self):\n        result = self.inventory.remove_item(\"shield\")\n        self.assertFalse(result)\n    \n    def test_has_item(self):\n        self.inventory.add_item(\"helmet\")\n        self.assertTrue(self.inventory.has_item(\"helmet\"))\n        self.assertFalse(self.inventory.has_item(\"boots\"))\n\n# Running specific tests\n# python -m unittest test_module.TestClass.test_method\n# python -m unittest discover  # Run all tests in directory",
    "syntax_notes": "Create test class inheriting from unittest.TestCase. Name test methods starting with 'test_'. Use self.assert* methods. setUp/tearDown run before/after each test. Use unittest.main() to run tests.",
    "common_mistakes": "[\"Not naming test methods with 'test_' prefix\", \"Testing implementation instead of behavior\", \"Writing tests that depend on each other\", \"Not testing edge cases\", \"Forgetting to run tests regularly\"]"
  }
]
