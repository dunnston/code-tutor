[
  {
    "concept_id": "classes-objects",
    "language_id": "python",
    "explanation": "Classes are blueprints for creating objects. Objects are instances of classes that contain both data (attributes) and behavior (methods). Classes help organize related code and data together.",
    "code_example": "# Defining a class\nclass Character:\n    pass  # Empty class for now\n\n# Creating objects (instances)\nhero = Character()\nvillain = Character()\n\nprint(type(hero))  # <class '__main__.Character'>\n\n# Class with attributes (data)\nclass Player:\n    pass\n\nplayer1 = Player()\nplayer1.name = \"Hero\"  # Setting attributes\nplayer1.health = 100\nplayer1.level = 5\n\nprint(f\"{player1.name} has {player1.health} HP\")\n\n# Better way: using __init__ (constructor)\nclass Enemy:\n    def __init__(self, name, health):\n        self.name = name  # Instance attribute\n        self.health = health\n\ngoblin = Enemy(\"Goblin\", 50)\ndragon = Enemy(\"Dragon\", 500)\n\nprint(goblin.name)  # \"Goblin\"\nprint(dragon.health)  # 500\n\n# Complete example\nclass Weapon:\n    def __init__(self, name, damage):\n        self.name = name\n        self.damage = damage\n        self.durability = 100  # Default value\n    \n    def display_info(self):  # Method\n        print(f\"{self.name}: {self.damage} damage, {self.durability}% durability\")\n\nsword = Weapon(\"Iron Sword\", 25)\nbow = Weapon(\"Longbow\", 30)\n\nsword.display_info()  # Iron Sword: 25 damage, 100% durability\nbow.display_info()  # Longbow: 30 damage, 100% durability",
    "syntax_notes": "Use 'class' keyword followed by name (PascalCase). self is the first parameter of all instance methods. __init__ is the constructor method called when creating objects. Create instances by calling ClassName().",
    "common_mistakes": "[\"Forgetting 'self' parameter in methods\", \"Using 'Class()' instead of 'class'\", \"Not understanding the difference between class and instance\", \"Forgetting parentheses when creating instances\"]"
  },
  {
    "concept_id": "properties-methods",
    "language_id": "python",
    "explanation": "Properties (attributes) store data in objects. Methods are functions defined inside a class that operate on that data. The 'self' parameter refers to the instance itself.",
    "code_example": "class Character:\n    def __init__(self, name, health):\n        # Instance properties/attributes\n        self.name = name\n        self.health = health\n        self.max_health = health\n        self.level = 1\n    \n    # Instance methods\n    def take_damage(self, damage):\n        self.health -= damage\n        if self.health < 0:\n            self.health = 0\n        print(f\"{self.name} took {damage} damage! HP: {self.health}/{self.max_health}\")\n    \n    def heal(self, amount):\n        self.health += amount\n        if self.health > self.max_health:\n            self.health = self.max_health\n        print(f\"{self.name} healed {amount} HP! HP: {self.health}/{self.max_health}\")\n    \n    def is_alive(self):\n        return self.health > 0\n    \n    def level_up(self):\n        self.level += 1\n        self.max_health += 10\n        self.health = self.max_health\n        print(f\"{self.name} leveled up to {self.level}!\")\n\n# Using the class\nhero = Character(\"Hero\", 100)\n\nhero.take_damage(30)  # Hero took 30 damage! HP: 70/100\nhero.heal(20)  # Hero healed 20 HP! HP: 90/100\nprint(hero.is_alive())  # True\nhero.level_up()  # Hero leveled up to 2!\n\n# Class attributes (shared by all instances)\nclass Enemy:\n    # Class attribute\n    total_enemies = 0\n    \n    def __init__(self, name):\n        self.name = name\n        Enemy.total_enemies += 1  # Access class attribute\n    \n    @classmethod\n    def get_total(cls):\n        return cls.total_enemies\n\ngoblin1 = Enemy(\"Goblin 1\")\ngoblin2 = Enemy(\"Goblin 2\")\nprint(Enemy.get_total())  # 2\n\n# Property decorators (advanced)\nclass Player:\n    def __init__(self, name):\n        self._name = name  # \"Private\" attribute\n        self._health = 100\n    \n    @property\n    def name(self):\n        return self._name\n    \n    @property\n    def health(self):\n        return self._health\n    \n    @health.setter\n    def health(self, value):\n        if value < 0:\n            self._health = 0\n        elif value > 100:\n            self._health = 100\n        else:\n            self._health = value\n\nplayer = Player(\"Hero\")\nprint(player.health)  # 100\nplayer.health = 150  # Setter ensures it won't go above 100\nprint(player.health)  # 100",
    "syntax_notes": "self always refers to the instance. Methods must have self as first parameter (except @classmethod and @staticmethod). Use dot notation to access properties and methods. Class attributes are shared by all instances.",
    "common_mistakes": "[\"Forgetting self parameter\", \"Trying to access instance attributes without self\", \"Confusing instance vs class attributes\", \"Not understanding that methods need () to call\"]"
  },
  {
    "concept_id": "constructors",
    "language_id": "python",
    "explanation": "The __init__ method is Python's constructor - it's automatically called when creating a new object. Use it to initialize object attributes and set up initial state.",
    "code_example": "# Basic constructor\nclass Weapon:\n    def __init__(self, name, damage):\n        self.name = name\n        self.damage = damage\n        print(f\"Created weapon: {name}\")\n\nsword = Weapon(\"Iron Sword\", 25)  # __init__ is called automatically\n\n# Constructor with default parameters\nclass Character:\n    def __init__(self, name, health=100, level=1):\n        self.name = name\n        self.health = health\n        self.level = level\n        self.inventory = []  # Initialize empty list\n\nhero = Character(\"Hero\")  # Uses defaults\nvillain = Character(\"Villain\", 150, 5)  # Custom values\n\n# Constructor with validation\nclass Player:\n    def __init__(self, name, age):\n        if not name:\n            raise ValueError(\"Name cannot be empty\")\n        if age < 0:\n            raise ValueError(\"Age cannot be negative\")\n        \n        self.name = name\n        self.age = age\n        self.created_at = \"2024-01-01\"  # Can compute values\n\n# player = Player(\"\", 25)  # Raises ValueError\nplayer = Player(\"Hero\", 25)  # Works!\n\n# Constructor calling other methods\nclass Game:\n    def __init__(self, title):\n        self.title = title\n        self.players = []\n        self.is_running = False\n        self._setup()  # Call helper method\n    \n    def _setup(self):\n        print(f\"Setting up game: {self.title}\")\n        self.is_running = True\n\ngame = Game(\"Epic Quest\")  # Automatically runs setup\n\n# Calling parent constructor (inheritance preview)\nclass Boss:\n    def __init__(self, name, health, special_ability):\n        self.name = name\n        self.health = health\n        self.special_ability = special_ability\n        self.is_boss = True\n\ndragon = Boss(\"Ancient Dragon\", 1000, \"Fire Breath\")\n\n# Constructor with computed attributes\nclass Quest:\n    def __init__(self, title, difficulty):\n        self.title = title\n        self.difficulty = difficulty\n        self.xp_reward = difficulty * 100  # Computed from difficulty\n        self.is_completed = False\n        self.attempts = 0\n\nquest = Quest(\"Slay the Dragon\", 5)\nprint(quest.xp_reward)  # 500",
    "syntax_notes": "__init__ is called automatically when creating objects. First parameter must be self. Can have additional parameters with defaults. Use it to set initial state. Don't use 'return' with a value in __init__.",
    "common_mistakes": "[\"Forgetting self parameter\", \"Returning a value from __init__\", \"Not calling parent __init__ in inheritance\", \"Using mutable defaults (like [] or {}) in parameters\"]"
  },
  {
    "concept_id": "inheritance",
    "language_id": "python",
    "explanation": "Inheritance allows a class to inherit attributes and methods from another class. The child class (subclass) gets all features of the parent class (superclass) and can add or override them.",
    "code_example": "# Basic inheritance\nclass Character:\n    def __init__(self, name, health):\n        self.name = name\n        self.health = health\n    \n    def take_damage(self, damage):\n        self.health -= damage\n        print(f\"{self.name} took {damage} damage!\")\n\n# Warrior inherits from Character\nclass Warrior(Character):\n    def __init__(self, name, health, armor):\n        super().__init__(name, health)  # Call parent constructor\n        self.armor = armor\n    \n    def shield_block(self):\n        print(f\"{self.name} blocks with shield!\")\n\nwarrior = Warrior(\"Conan\", 150, 50)\nwarrior.take_damage(20)  # Inherited method\nwarrior.shield_block()  # New method\n\n# Mage also inherits from Character\nclass Mage(Character):\n    def __init__(self, name, health, mana):\n        super().__init__(name, health)\n        self.mana = mana\n    \n    def cast_spell(self, spell_name, cost):\n        if self.mana >= cost:\n            self.mana -= cost\n            print(f\"{self.name} casts {spell_name}!\")\n        else:\n            print(\"Not enough mana!\")\n\nmage = Mage(\"Gandalf\", 80, 100)\nmage.cast_spell(\"Fireball\", 30)\n\n# Method overriding\nclass Boss(Character):\n    def __init__(self, name, health):\n        super().__init__(name, health)\n        self.enraged = False\n    \n    def take_damage(self, damage):  # Override parent method\n        reduced_damage = damage // 2  # Bosses take half damage\n        super().take_damage(reduced_damage)  # Call parent implementation\n        \n        if self.health < 50 and not self.enraged:\n            self.enraged = True\n            print(f\"{self.name} becomes enraged!\")\n\ndragon = Boss(\"Dragon\", 200)\ndragon.take_damage(60)  # Takes 30 damage (half of 60)\n\n# Multiple levels of inheritance\nclass Entity:\n    def __init__(self, name):\n        self.name = name\n\nclass Character(Entity):\n    def __init__(self, name, health):\n        super().__init__(name)\n        self.health = health\n\nclass Player(Character):\n    def __init__(self, name, health, player_id):\n        super().__init__(name, health)\n        self.player_id = player_id\n\nplayer = Player(\"Hero\", 100, 12345)\nprint(player.name)  # From Entity\nprint(player.health)  # From Character\nprint(player.player_id)  # From Player\n\n# Checking inheritance\nprint(isinstance(warrior, Warrior))  # True\nprint(isinstance(warrior, Character))  # True\nprint(isinstance(mage, Warrior))  # False",
    "syntax_notes": "Inherit by putting parent class in parentheses: class Child(Parent). Use super() to call parent methods. Child class gets all parent attributes and methods. Can override methods by defining them again.",
    "common_mistakes": "[\"Forgetting to call super().__init__()\", \"Not understanding method resolution order\", \"Overriding methods without calling parent version when needed\", \"Confusing is-a vs has-a relationships\"]"
  },
  {
    "concept_id": "polymorphism",
    "language_id": "python",
    "explanation": "Polymorphism allows objects of different classes to be used interchangeably if they share a common interface. The same method name can behave differently for different classes.",
    "code_example": "# Polymorphism through inheritance\nclass Character:\n    def __init__(self, name):\n        self.name = name\n    \n    def attack(self):\n        raise NotImplementedError(\"Subclass must implement attack()\")\n    \n    def get_description(self):\n        return f\"{self.name} the {self.__class__.__name__}\"\n\nclass Warrior(Character):\n    def attack(self):\n        return f\"{self.name} swings sword for 25 damage!\"\n\nclass Mage(Character):\n    def attack(self):\n        return f\"{self.name} casts fireball for 40 damage!\"\n\nclass Archer(Character):\n    def attack(self):\n        return f\"{self.name} shoots arrow for 20 damage!\"\n\n# Polymorphism in action - same method, different behavior\ncharacters = [\n    Warrior(\"Conan\"),\n    Mage(\"Gandalf\"),\n    Archer(\"Legolas\")\n]\n\nfor character in characters:\n    print(character.attack())  # Each calls their own version\n    # Conan swings sword for 25 damage!\n    # Gandalf casts fireball for 40 damage!\n    # Legolas shoots arrow for 20 damage!\n\n# Duck typing (if it walks like a duck and quacks like a duck...)\nclass Dragon:\n    def __init__(self, name):\n        self.name = name\n    \n    def attack(self):\n        return f\"{self.name} breathes fire for 100 damage!\"\n\n# Dragon doesn't inherit from Character, but has attack() method\ndragon = Dragon(\"Smaug\")\ncharacters.append(dragon)\n\nfor character in characters:\n    print(character.attack())  # Works for Dragon too!\n\n# Polymorphism with operators (__str__, __repr__, etc.)\nclass Item:\n    def __init__(self, name, value):\n        self.name = name\n        self.value = value\n    \n    def __str__(self):\n        return f\"{self.name} (${self.value})\"\n    \n    def __repr__(self):\n        return f\"Item('{self.name}', {self.value})\"\n    \n    def __add__(self, other):\n        if isinstance(other, Item):\n            return self.value + other.value\n        return self.value + other\n\nsword = Item(\"Sword\", 100)\nshield = Item(\"Shield\", 75)\n\nprint(sword)  # Sword ($100) - calls __str__\nprint(repr(sword))  # Item('Sword', 100) - calls __repr__\ntotal = sword + shield  # 175 - calls __add__\nprint(total)\n\n# Practical example: game entities\nclass GameObject:\n    def update(self):\n        pass\n    \n    def render(self):\n        pass\n\nclass Player(GameObject):\n    def update(self):\n        print(\"Updating player position\")\n    \n    def render(self):\n        print(\"Rendering player sprite\")\n\nclass Enemy(GameObject):\n    def update(self):\n        print(\"Updating enemy AI\")\n    \n    def render(self):\n        print(\"Rendering enemy sprite\")\n\nclass Collectible(GameObject):\n    def update(self):\n        print(\"Checking if player collected item\")\n    \n    def render(self):\n        print(\"Rendering collectible sprite\")\n\n# Game loop can treat all objects the same way\ngame_objects = [Player(), Enemy(), Collectible()]\n\nfor obj in game_objects:\n    obj.update()  # Polymorphism!\n    obj.render()  # Each object handles it differently",
    "syntax_notes": "Polymorphism means 'many forms'. Same interface, different implementations. Python uses duck typing - if an object has the right methods, it works. Override special methods (__str__, __add__, etc.) for operator polymorphism.",
    "common_mistakes": "[\"Not providing a common interface\", \"Forgetting that duck typing doesn't require inheritance\", \"Overcomplicating with unnecessary inheritance\", \"Not understanding when to use polymorphism vs composition\"]"
  }
]
