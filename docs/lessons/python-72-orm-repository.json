{
  "id": 72,
  "trackId": 8,
  "language": "python",
  "title": "The Repository Sanctum",
  "subtitle": "ORM Pattern & Repository Layer",
  "difficulty": 5,
  "estimatedTime": "45-55 minutes",
  "xpReward": 250,
  "description": "# Master the Repository Pattern!\n\nðŸ›ï¸ **Repository pattern** separates data access logic from business logic.\n\n## Why Repository Pattern?\n\n- **Separation of concerns** - Business logic doesn't know about SQL\n- **Testability** - Easy to mock repositories\n- **Flexibility** - Change database without changing business code\n- **DRY** - Reusable data access methods\n\n## Repository Pattern\n\n```python\nclass CharacterRepository:\n    def __init__(self, db_path='game.db'):\n        self.db_path = db_path\n    \n    def get_by_id(self, char_id):\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        cursor.execute('SELECT * FROM characters WHERE id = ?', (char_id,))\n        row = cursor.fetchone()\n        conn.close()\n        \n        if row:\n            return Character(row[0], row[1], row[2], row[3])\n        return None\n    \n    def save(self, character):\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        \n        if character.id is None:\n            # Insert\n            cursor.execute(\n                'INSERT INTO characters (name, level, health) VALUES (?, ?, ?)',\n                (character.name, character.level, character.health)\n            )\n            character.id = cursor.lastrowid\n        else:\n            # Update\n            cursor.execute(\n                'UPDATE characters SET name=?, level=?, health=? WHERE id=?',\n                (character.name, character.level, character.health, character.id)\n            )\n        \n        conn.commit()\n        conn.close()\n    \n    def find_by_level(self, min_level):\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        cursor.execute('SELECT * FROM characters WHERE level >= ?', (min_level,))\n        rows = cursor.fetchall()\n        conn.close()\n        \n        return [Character(r[0], r[1], r[2], r[3]) for r in rows]\n```\n\n## Your Mission\n\nBuild a complete repository system:\n1. **Character model** - Python class representing data\n2. **CharacterRepository** - Data access layer\n3. **ItemRepository** - Items with CRUD operations\n4. **Base Repository** - Shared functionality\n\nâš”ï¸ Build a professional data layer!\n\n*Hint: Repositories hide SQL complexity from business code.*",
  "starterCode": "import sqlite3\nfrom typing import Optional, List\n\n# ===== MODELS =====\n\nclass Character:\n    def __init__(self, id=None, name='', level=1, health=100):\n        self.id = id\n        self.name = name\n        self.level = level\n        self.health = health\n    \n    def __repr__(self):\n        return f\"Character(id={self.id}, name='{self.name}', level={self.level}, health={self.health})\"\n\nclass Item:\n    def __init__(self, id=None, name='', item_type='', value=0):\n        self.id = id\n        self.name = name\n        self.item_type = item_type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Item(id={self.id}, name='{self.name}', type='{self.item_type}', value={self.value})\"\n\n# ===== BASE REPOSITORY =====\n\nclass BaseRepository:\n    \"\"\"Base repository with shared database functionality\"\"\"\n    \n    def __init__(self, db_path='game.db'):\n        self.db_path = db_path\n    \n    def _get_connection(self):\n        return sqlite3.connect(self.db_path)\n    \n    # TODO: Implement _execute_query(sql, params) helper\n    # Should execute query and return cursor\n    \n    # TODO: Implement _fetch_one(sql, params) helper\n    # Should execute and return single row\n    \n    # TODO: Implement _fetch_all(sql, params) helper\n    # Should execute and return all rows\n\n# ===== CHARACTER REPOSITORY =====\n\nclass CharacterRepository(BaseRepository):\n    \n    def create_table(self):\n        \"\"\"Create characters table\"\"\"\n        conn = self._get_connection()\n        cursor = conn.cursor()\n        cursor.execute('''\n            CREATE TABLE IF NOT EXISTS characters (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                name TEXT NOT NULL,\n                level INTEGER DEFAULT 1,\n                health INTEGER DEFAULT 100\n            )\n        ''')\n        conn.commit()\n        conn.close()\n    \n    # TODO: Implement get_by_id(char_id) -> Optional[Character]\n    # Fetch character by ID, return Character object or None\n    \n    # TODO: Implement save(character) -> Character\n    # Insert if id is None, update if id exists\n    # Return the character with updated id\n    \n    # TODO: Implement delete(char_id) -> bool\n    # Delete character by ID, return True if deleted\n    \n    # TODO: Implement get_all() -> List[Character]\n    # Return all characters\n    \n    # TODO: Implement find_by_level(min_level) -> List[Character]\n    # Return characters with level >= min_level\n\n# ===== ITEM REPOSITORY =====\n\nclass ItemRepository(BaseRepository):\n    \n    def create_table(self):\n        \"\"\"Create items table\"\"\"\n        conn = self._get_connection()\n        cursor = conn.cursor()\n        cursor.execute('''\n            CREATE TABLE IF NOT EXISTS items (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                name TEXT NOT NULL,\n                item_type TEXT NOT NULL,\n                value INTEGER DEFAULT 0\n            )\n        ''')\n        conn.commit()\n        conn.close()\n    \n    # TODO: Implement get_by_id(item_id) -> Optional[Item]\n    \n    # TODO: Implement save(item) -> Item\n    \n    # TODO: Implement delete(item_id) -> bool\n    \n    # TODO: Implement get_all() -> List[Item]\n    \n    # TODO: Implement find_by_type(item_type) -> List[Item]\n    # Return all items of a specific type\n\n# ===== TESTS =====\n\nif __name__ == \"__main__\":\n    print(\"Testing Repository Pattern...\")\n    \n    # Setup\n    char_repo = CharacterRepository('test.db')\n    item_repo = ItemRepository('test.db')\n    \n    char_repo.create_table()\n    item_repo.create_table()\n    \n    # Test Character Repository\n    print(\"\\n=== Character Repository ===\")\n    \n    # Create characters\n    hero = Character(name=\"Aragorn\", level=10, health=150)\n    villain = Character(name=\"Sauron\", level=50, health=500)\n    \n    hero = char_repo.save(hero)\n    villain = char_repo.save(villain)\n    \n    print(f\"Created: {hero}\")\n    print(f\"Created: {villain}\")\n    \n    # Get by ID\n    retrieved = char_repo.get_by_id(hero.id)\n    print(f\"Retrieved: {retrieved}\")\n    \n    # Update\n    hero.level = 15\n    hero.health = 180\n    char_repo.save(hero)\n    updated = char_repo.get_by_id(hero.id)\n    print(f\"Updated: {updated}\")\n    \n    # Find by level\n    high_level = char_repo.find_by_level(15)\n    print(f\"High level characters: {high_level}\")\n    \n    # Get all\n    all_chars = char_repo.get_all()\n    print(f\"All characters: {len(all_chars)}\")\n    \n    # Test Item Repository\n    print(\"\\n=== Item Repository ===\")\n    \n    sword = Item(name=\"Excalibur\", item_type=\"weapon\", value=1000)\n    potion = Item(name=\"Health Potion\", item_type=\"consumable\", value=50)\n    \n    sword = item_repo.save(sword)\n    potion = item_repo.save(potion)\n    \n    print(f\"Created: {sword}\")\n    print(f\"Created: {potion}\")\n    \n    # Find by type\n    weapons = item_repo.find_by_type(\"weapon\")\n    print(f\"Weapons: {weapons}\")\n    \n    # Delete\n    char_repo.delete(villain.id)\n    print(f\"Characters after delete: {len(char_repo.get_all())}\")\n    \n    print(\"\\nâœ… Repository pattern tests complete!\")",
  "solutionCode": "import sqlite3\nfrom typing import Optional, List\n\nclass Character:\n    def __init__(self, id=None, name='', level=1, health=100):\n        self.id = id\n        self.name = name\n        self.level = level\n        self.health = health\n    \n    def __repr__(self):\n        return f\"Character(id={self.id}, name='{self.name}', level={self.level}, health={self.health})\"\n\nclass Item:\n    def __init__(self, id=None, name='', item_type='', value=0):\n        self.id = id\n        self.name = name\n        self.item_type = item_type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Item(id={self.id}, name='{self.name}', type='{self.item_type}', value={self.value})\"\n\nclass BaseRepository:\n    def __init__(self, db_path='game.db'):\n        self.db_path = db_path\n    \n    def _get_connection(self):\n        return sqlite3.connect(self.db_path)\n    \n    def _execute_query(self, sql, params=()):\n        conn = self._get_connection()\n        cursor = conn.cursor()\n        cursor.execute(sql, params)\n        conn.commit()\n        last_id = cursor.lastrowid\n        conn.close()\n        return last_id\n    \n    def _fetch_one(self, sql, params=()):\n        conn = self._get_connection()\n        cursor = conn.cursor()\n        cursor.execute(sql, params)\n        result = cursor.fetchone()\n        conn.close()\n        return result\n    \n    def _fetch_all(self, sql, params=()):\n        conn = self._get_connection()\n        cursor = conn.cursor()\n        cursor.execute(sql, params)\n        results = cursor.fetchall()\n        conn.close()\n        return results\n\nclass CharacterRepository(BaseRepository):\n    \n    def create_table(self):\n        conn = self._get_connection()\n        cursor = conn.cursor()\n        cursor.execute('''\n            CREATE TABLE IF NOT EXISTS characters (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                name TEXT NOT NULL,\n                level INTEGER DEFAULT 1,\n                health INTEGER DEFAULT 100\n            )\n        ''')\n        conn.commit()\n        conn.close()\n    \n    def get_by_id(self, char_id) -> Optional[Character]:\n        row = self._fetch_one('SELECT * FROM characters WHERE id = ?', (char_id,))\n        if row:\n            return Character(row[0], row[1], row[2], row[3])\n        return None\n    \n    def save(self, character) -> Character:\n        if character.id is None:\n            last_id = self._execute_query(\n                'INSERT INTO characters (name, level, health) VALUES (?, ?, ?)',\n                (character.name, character.level, character.health)\n            )\n            character.id = last_id\n        else:\n            self._execute_query(\n                'UPDATE characters SET name=?, level=?, health=? WHERE id=?',\n                (character.name, character.level, character.health, character.id)\n            )\n        return character\n    \n    def delete(self, char_id) -> bool:\n        self._execute_query('DELETE FROM characters WHERE id = ?', (char_id,))\n        return True\n    \n    def get_all(self) -> List[Character]:\n        rows = self._fetch_all('SELECT * FROM characters')\n        return [Character(r[0], r[1], r[2], r[3]) for r in rows]\n    \n    def find_by_level(self, min_level) -> List[Character]:\n        rows = self._fetch_all('SELECT * FROM characters WHERE level >= ?', (min_level,))\n        return [Character(r[0], r[1], r[2], r[3]) for r in rows]\n\nclass ItemRepository(BaseRepository):\n    \n    def create_table(self):\n        conn = self._get_connection()\n        cursor = conn.cursor()\n        cursor.execute('''\n            CREATE TABLE IF NOT EXISTS items (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                name TEXT NOT NULL,\n                item_type TEXT NOT NULL,\n                value INTEGER DEFAULT 0\n            )\n        ''')\n        conn.commit()\n        conn.close()\n    \n    def get_by_id(self, item_id) -> Optional[Item]:\n        row = self._fetch_one('SELECT * FROM items WHERE id = ?', (item_id,))\n        if row:\n            return Item(row[0], row[1], row[2], row[3])\n        return None\n    \n    def save(self, item) -> Item:\n        if item.id is None:\n            last_id = self._execute_query(\n                'INSERT INTO items (name, item_type, value) VALUES (?, ?, ?)',\n                (item.name, item.item_type, item.value)\n            )\n            item.id = last_id\n        else:\n            self._execute_query(\n                'UPDATE items SET name=?, item_type=?, value=? WHERE id=?',\n                (item.name, item.item_type, item.value, item.id)\n            )\n        return item\n    \n    def delete(self, item_id) -> bool:\n        self._execute_query('DELETE FROM items WHERE id = ?', (item_id,))\n        return True\n    \n    def get_all(self) -> List[Item]:\n        rows = self._fetch_all('SELECT * FROM items')\n        return [Item(r[0], r[1], r[2], r[3]) for r in rows]\n    \n    def find_by_type(self, item_type) -> List[Item]:\n        rows = self._fetch_all('SELECT * FROM items WHERE item_type = ?', (item_type,))\n        return [Item(r[0], r[1], r[2], r[3]) for r in rows]\n\nif __name__ == \"__main__\":\n    print(\"Testing Repository Pattern...\")\n    \n    char_repo = CharacterRepository('test.db')\n    item_repo = ItemRepository('test.db')\n    \n    char_repo.create_table()\n    item_repo.create_table()\n    \n    print(\"\\n=== Character Repository ===\")\n    \n    hero = Character(name=\"Aragorn\", level=10, health=150)\n    villain = Character(name=\"Sauron\", level=50, health=500)\n    \n    hero = char_repo.save(hero)\n    villain = char_repo.save(villain)\n    \n    print(f\"Created: {hero}\")\n    print(f\"Created: {villain}\")\n    \n    retrieved = char_repo.get_by_id(hero.id)\n    print(f\"Retrieved: {retrieved}\")\n    \n    hero.level = 15\n    hero.health = 180\n    char_repo.save(hero)\n    updated = char_repo.get_by_id(hero.id)\n    print(f\"Updated: {updated}\")\n    \n    high_level = char_repo.find_by_level(15)\n    print(f\"High level characters: {high_level}\")\n    \n    all_chars = char_repo.get_all()\n    print(f\"All characters: {len(all_chars)}\")\n    \n    print(\"\\n=== Item Repository ===\")\n    \n    sword = Item(name=\"Excalibur\", item_type=\"weapon\", value=1000)\n    potion = Item(name=\"Health Potion\", item_type=\"consumable\", value=50)\n    \n    sword = item_repo.save(sword)\n    potion = item_repo.save(potion)\n    \n    print(f\"Created: {sword}\")\n    print(f\"Created: {potion}\")\n    \n    weapons = item_repo.find_by_type(\"weapon\")\n    print(f\"Weapons: {weapons}\")\n    \n    char_repo.delete(villain.id)\n    print(f\"Characters after delete: {len(char_repo.get_all())}\")\n    \n    print(\"\\nâœ… Repository pattern tests complete!\")",
  "hints": [
    "BaseRepository should have helper methods that child classes use. This reduces code duplication.",
    "For save(), check if id is None to decide INSERT vs UPDATE.",
    "The _fetch_one and _fetch_all helpers handle connection management, so child classes just call them.",
    "After INSERT, get cursor.lastrowid to set the object's id.",
    "Repository methods return domain objects (Character, Item), not raw database rows."
  ],
  "validationTests": [
    {
      "type": "code_contains",
      "value": "class BaseRepository",
      "description": "Must implement BaseRepository"
    },
    {
      "type": "code_contains",
      "value": "class CharacterRepository(BaseRepository)",
      "description": "CharacterRepository must inherit from BaseRepository"
    },
    {
      "type": "code_contains",
      "value": "def get_by_id",
      "description": "Must implement get_by_id method"
    },
    {
      "type": "code_contains",
      "value": "def save",
      "description": "Must implement save method"
    },
    {
      "type": "code_contains",
      "value": "def find_by_level",
      "description": "Must implement find_by_level method"
    },
    {
      "type": "code_contains",
      "value": "def find_by_type",
      "description": "ItemRepository must implement find_by_type"
    },
    {
      "type": "output_contains",
      "value": "Repository pattern tests complete",
      "description": "Tests should complete successfully"
    }
  ],
  "learningObjectives": [
    "Implement repository pattern for data access",
    "Create base repository with shared functionality",
    "Build domain models separate from database",
    "Implement CRUD operations in repositories",
    "Use inheritance to reduce code duplication",
    "Abstract database details from business logic"
  ],
  "nextLessonId": 73,
  "previousLessonId": 71,
  "tags": ["advanced", "database", "repository", "orm", "patterns", "architecture"],
  "commonMistakes": [
    {
      "mistake": "Putting business logic in repositories",
      "explanation": "Repositories should ONLY handle data access. Business logic belongs in service classes."
    },
    {
      "mistake": "Returning database rows instead of domain objects",
      "explanation": "Repositories should return Character/Item objects, not raw tuples from the database."
    },
    {
      "mistake": "Not closing database connections",
      "explanation": "Always close connections after operations. Use helper methods to ensure this."
    },
    {
      "mistake": "Duplicating connection code in every method",
      "explanation": "Use base class helper methods like _fetch_one(), _fetch_all() to centralize connection handling."
    }
  ]
}
